# DB

## 트랜잭션이란?
- 트랜잭션이란 데이터베이스의 상태를 변화시키는 하나으 논리적인 작업 단위를 구성하는 연산들의 집합이다

## 트랜잭션의 4가지 속성
- Atomicity(원자성)
  - 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다
- Consistency(일관성)
  - 트랜잭션 완료 후에도 데이터베이스가 일관된 상태로 유지되어야 한다
- Isolation(고립성)
  - 둘 이상의 트랜잭션이 동시에 실행되고 있는 경우, 어떤 하나의 트랜잭션이라도 트랜잭션 연산에 끼어들 수 없다는 것
- Durability(지속성)
  - 트랜잭션이 성공적으로 완료된 경우, 결과는 영구적으로 반영되어야 한다는 것

## 트랜잭션을 왜 사용할까?
- 데이터 무결성 보장
- 예기치 못한 오류가 발생하더라도 데이터베이스의 일관성을 유지할 수 있다

## 데이터 무결성(Integrity)
- 데이터가 정확하고 완전함
- 관계형 데이터베이스의 가장 큰 목표는 데이터 무결성을 높이는 것
- 무결성의 종류
  - 엔티티 무결성
    - 모든 인스턴스는 고유한 값이거나 null값을 가지면 안됨
  - 참조 무결성
    - FK는 참조되는 엔티티의 PK와 일치하거나 null값이어야 함
  - 도메인 무결성
    - 속성 값은 해당 속성에 정의된 도메인에 속한 값이어야 함
  - 비즈니스 무결성
    - 기업에서 요구하는 데이터 처리 규칙을 따라야 함

## 데이터 일관성/정합성(Consistency)
- 데이터들이 값이 서로 일치함  
- 정규화가 안되서 Anomaly(이상현상)이 발생하면 중복 데이터가 발생하고 결과적으로 정합성이 깨지게 됨  

## 트랜잭션의 상태
<img width="541" alt="스크린샷 2022-02-11 오후 12 15 08" src="https://user-images.githubusercontent.com/66231761/153532419-13438d9d-810e-45c1-8a75-bc0e6e717358.png">
- commit
  - 현재까지의 데이터 변경사항을 영구적으로 적용하고 트랜잭션을 종료하는 명령
- rollback
  - 현재 트랜잭션의 보류중인 모든 데이터 변경사항을 폐기하고 직전 커밋 직후 단계로 되돌아가는 명령
- partially Committed
  - 트랜잭션 마지막 연산까지 실행되고 Commit 연산 실행 직전 상태

## Lock
- Lock이란 트랜잭션 처리의 순차성을 보장하기 위한 방법이다
- Lock의 종류
  - 공유(Shared) lock
    - 데이터를 읽을 때 사용되는 lock
    - 공유 lock끼리는 동시 접근이 가능
    - 공유 lock이 설정된 데이터에 베타 lock은 사용불가
  - 베타(Exclusive) lock
    - 데이터 변경시 사용되고 트랜잭션 완료까지 유지되는 lock
    - 베타 lock이 해제될 때까지 다른 트랜잭션은 해당 리소스에 접근할 수 없다

## Lock 설정 범위(Level)
- database lock
  - 전체 데이터베이스 lock
  - db 소프트웨어 버전 업데이트시 사용
- table lock
  -  테이블 기준으로 lock
  -  테이블 전체(모든 행)에 영향을 주는 변경시 사용
  -  DDL(CREATE, ALTER, DROP)과 함께 사용
- row lock
  - 행을 기준으로 lock
  - DML(INSERT, SELECT, UPDATE, DELETE)과 함께 사용

## 블로킹(Blocking)
- lock간 경합이 발생해서 특정 Transaction이 작업을 진행하지 못하고 멈춘 상태
- (베타 & 베타) or (베타 & 공유) 끼리 발생
- (공유 & 공유)는 발생하지 않음
- 블로킹을 해소하기 위해선 commit이나 rollback으로 트랜잭션을 종료해야 한다
- 블로킹은 성능에 좋지 않은 영향을 주므로 블로킹을 최소화해야 함

## 교착상태(DeadLock)
- 두 트랜잭션이 각각 lock을 설정하고 서로의 리소스를 얻고자할 때(lock이 풀리길 기다림) 양쪽 트랜잭션 모두 영원히 처리되지 않게 되는 상태

<img width="420" alt="스크린샷 2022-02-11 오후 12 53 22" src="https://user-images.githubusercontent.com/66231761/153535150-bdae3e93-82ac-47c7-9af0-0d317bc5e032.png">
- Deadlock 발생시 둘 중 한 트랜잭션에 에러를 발생시킴으로써 문제를 해결한다
- 교착상태가 발생할 가능성을 줄이기 위해 수정과 조회 연산을 동시에 수행하는 로직을 지향한다
- 위 예시에선 update 연산이 완료되면 commit을 호출해서 테이블 접근 교차가 일어나지 않도록 한다

- 트랜잭션 격리 수준

- 인덱스
    - B-Tree B*-Tree
    - 클러스터 인덱스 논클러스터 인덱스
- 1~3 정규화 샘플 예제까지 포함
    - 왜 정규화를 할까?

## OS

- Process vs Thread 의차이
    - 언제 무엇을 쓰는 것이 좋을까?
- Multi Process vs Multi Thread
- Heap 영역 Stack 영역 차이
    - stack은 정적인 처리, 스택 방식으로 마지막 요청부터 순차적으로 처리
    - heap은 동적인 처리
- Lace Condition 경합 상태
    - Lace Condition 또는 데드락을 회피 할수 있는 방법
- 동시성이슈
    - 하나의 어플리케이션내에서 (스레드끼리 동시성 이슈) 처리방법
    - 서로다른 어플리케이션에서 (프로세스 끼리 동시성 이슈) 처리 방법
    - 같은 DB를 바라볼 때 일어나는 이슈
- 인프런에서 slow query 인덱스로 인한 장애

# 네이버 메인페이지 트래픽 분산 방법

# References
- https://spidyweb.tistory.com/164
- https://github.com/WeareSoft/tech-interview
- https://sabarada.tistory.com/121
